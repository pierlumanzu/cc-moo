random.seed(16007)

        efficient_point_idx = paretoEfficient(f_list)
        p_list = p_list[efficient_point_idx, :]
        f_list = f_list[efficient_point_idx, :]

        encountered_supports = []
        point_support_matching = None

        for index_p in range(len(p_list)):
            if len(np.where(np.abs(p_list[index_p, :]) > self.__sparse_tol)[0]) < problem.s:
                J_k = problem.evaluateFunctionsJacobian(p_list[index_p, :])
                self.addToStoppingConditionCurrentValue('max_f_evals', problem.n)

                z_k, theta_k = self.__additional_direction_solver.computeDirection(problem, J_k, p_list[index_p, :], self.getStoppingConditionReferenceValue('max_time') - self.getStoppingConditionCurrentValue('max_time'))

                try:
                    assert np.linalg.norm(z_k, 0) <= problem.s

                    if not self.evaluateStoppingConditions() and theta_k < self._theta_tol:
                        new_p, new_f, _, f_eval_ls = self.__additional_line_search.search(problem, p_list[index_p, :], z_k - p_list[index_p, :], f_list[index_p, :], J_k)
                        self.addToStoppingConditionCurrentValue('max_f_evals', f_eval_ls)

                        if not self.evaluateStoppingConditions() and new_p is not None:
                            p_list[index_p, :] = new_p
                            f_list[index_p, :] = new_f

                except AssertionError:
                    print(str(index_p), np.linalg.norm(z_k, 0), problem.s, np.sum(np.abs(z_k) < self.__sparse_tol))
                    if np.sum(np.abs(z_k) < self.__sparse_tol) >= problem.n - problem.s:
                        z_k[np.abs(z_k) < self.__sparse_tol] = 0

                        if not self.evaluateStoppingConditions() and theta_k < self._theta_tol:
                            new_p, new_f, _, f_eval_ls = self.__additional_line_search.search(problem, p_list[index_p, :], z_k - p_list[index_p, :], f_list[index_p, :], J_k)
                            self.addToStoppingConditionCurrentValue('max_f_evals', f_eval_ls)

                            if not self.evaluateStoppingConditions() and new_p is not None:
                                p_list[index_p, :] = new_p
                                f_list[index_p, :] = new_f
                    else:
                        print('Warning!')
                        print(z_k)

            support = list(np.where(np.abs(p_list[index_p, :]) > self.__sparse_tol)[0])
            if support not in encountered_supports:
                encountered_supports.append(support)
                point_support_matching = np.concatenate((point_support_matching, np.array([len(encountered_supports) - 1]))) if point_support_matching is not None else np.array([len(encountered_supports) - 1])
            else:
                point_support_matching = np.concatenate((point_support_matching, np.array([encountered_supports.index(support)]))) if point_support_matching is not None else np.array([encountered_supports.index(support)])

        for index_support_1 in range(len(encountered_supports) - 1, -1, -1):
            if len(encountered_supports[index_support_1]) < problem.s:
                for index_support_2 in range(len(encountered_supports)):
                    if index_support_2 != index_support_1:
                        if set(encountered_supports[index_support_1]) <= set(encountered_supports[index_support_2]) and len(encountered_supports[index_support_2]) == problem.s:
                            del encountered_supports[index_support_1]

                            matching_to_change = np.where(point_support_matching == index_support_1)[0]

                            for index_matching in range(len(point_support_matching)):
                                if point_support_matching[index_matching] > index_support_1:
                                    point_support_matching[index_matching] -= 1

                            point_support_matching[matching_to_change] = index_support_2 - (1 if index_support_2 > index_support_1 else 0)

                            break

                    if index_support_2 == len(encountered_supports) - 1:
                        while len(encountered_supports[index_support_1]) < problem.s:
                            random_number = random.randint(0, problem.n - 1)
                            while random_number in encountered_supports[index_support_1]:
                                random_number = random.randint(0, problem.n - 1)
                            encountered_supports[index_support_1].append(random_number)